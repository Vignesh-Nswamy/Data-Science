---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from sklearn.model_selection import train_test_split
import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler  
from scipy.cluster.hierarchy import linkage, fcluster
from sklearn.cluster import KMeans, DBSCAN
from sklearn import metrics
```

```{python}
data = pd.read_csv(os.getcwd() + '\data\merged_train.csv')
# data['Party'].describe()
data.head()
```

```{python}
# columns = np.array([i for i in range(4, 16)], dtype=np.intp) # All columns
columns = np.array([4, 5, 6, 7, 10, 11, 12, 14, 15], dtype=np.intp) # All columns
# columns = np.array([3, 4, 5, 7, 10, 14, 15], dtype=np.intp) # All columns
# columns = np.array([3, 4, 5, 6, 7, 11, 14, 15], dtype=np.intp) # All columns
print('Columns being used for building the classifier: {}'.format( data.iloc[:, columns].columns ))
X = data.iloc[:, columns]
y = data['Party']
```

```{python}
scaler = StandardScaler()
scaler.fit(X)
X = scaler.transform(X)
```

```{python}
def evaluate(X, y_test, y_pred):
    ret_str = ''
    ret_str += 'Adjusted Rand Index: {}'.format( metrics.adjusted_rand_score(y_test, y_pred) ) + '\n'
    ret_str += 'Silhouette Coefficient: {}'.format( metrics.silhouette_score(X, y_pred, metric = "euclidean") )
    return ret_str
```

```{python}
def k_means(X, y_test):
    clustering = KMeans(n_clusters = 2, n_init = 1, init = 'random', max_iter=15, random_state = 0).fit(X)
    clusters = clustering.labels_
    cont_matrix = metrics.cluster.contingency_matrix(y_test, clusters)
    sns.heatmap(cont_matrix, annot = True, fmt = ".3f", square = True, cmap = plt.cm.Blues)
    plt.ylabel('Actual')
    plt.xlabel('Predicted')
    plt.title('Contingency matrix')
    plt.tight_layout()
    print(evaluate(X, y_test, clusters))
```

```{python}
k_means(X, y)
```

```{python}
def dbscan(X, y_test):
    clustering = DBSCAN(eps = 3, min_samples = 3, metric = "euclidean").fit(X)
    clusters = clustering.labels_
    cont_matrix = metrics.cluster.contingency_matrix(y_test, clusters)
    sns.heatmap(cont_matrix, annot = True, fmt = ".3f", square = True, cmap = plt.cm.Blues)
    plt.ylabel('Actual')
    plt.xlabel('Predicted')
    plt.title('Contingency matrix')
    plt.tight_layout()
    print(evaluate(X, y_test, clusters))
```

```{python}
dbscan(X, y)
```

```{python}
def hierarchical(X, y_test, method='single', metric='euclidean'):
    clustering = linkage(X, method = method, metric = metric)
    clusters = fcluster(clustering, 2, criterion = 'maxclust')
    cont_matrix = metrics.cluster.contingency_matrix(y_test, clusters)
    sns.heatmap(cont_matrix, annot = True, fmt = ".3f", square = True, cmap = plt.cm.Blues)
    plt.ylabel('Actual')
    plt.xlabel('Predicted')
    plt.title('Contingency matrix')
    plt.tight_layout()
    print(evaluate(X, y_test, clusters))
```

```{python}
hierarchical(X, y)
```

```{python}
hierarchical(X, y, method='ward')
```

```{python}

```

```{python}

```
